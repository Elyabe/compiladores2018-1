options {
  DEBUG_PARSER = false;
  DEBUG_TOKEN_MANAGER = false;
}

PARSER_BEGIN(Compilador)
package parser;

import java.io.*;
import semantico.*;
import geradorCodigo.*;
import apoio.*;
import primeiraPassagem.*;
import segundaPassagem.*;
import jasmin.*;

public class Compilador {
  
  	public static boolean error=false;
	public static Tabela tabela = new Tabela();
	public static ListaComandoAltoNivel listaMain = null;
	public static ListaComandosPrimitivos listaPrimitiva = null;
	public static CodigoDestino codigoDestino = null;

   public static void main(String args[])  throws ParseException  {
      Compilador compilador;
      try {
         compilador = new Compilador(new FileInputStream(Config.arqfonte));
         listaMain = Compilador.inicio();
  	      if(!error)
	      	System.out.println("\nSem erros sintáticos\n");
	      else
	      	System.out.println("\nForam encontrados erros sintáticos, mas foram ignorados para melhor análise\n");
		 System.out.println("\nTabela:\n"+tabela.toString());
         if (listaMain!=null)
         	System.out.println("\nComandos Alto Nivel:\n"+listaMain.toString());
         listaPrimitiva=listaMain.geraListaComandosPrimitivosTotal();
         if (listaPrimitiva!=null)
         	System.out.println("\nComandos Primitivos:\n"+listaPrimitiva.toString());
         codigoDestino = new CodigoDestino(listaPrimitiva);	
         System.out.println("\nCodigo Destino:\n"+listaPrimitiva.geraCodigoDestinoTotal());	
      }
      catch(FileNotFoundException e) {
         System.out.println("Erro: arquivo nao encontrado");
      }
      catch(TokenMgrError e) {
         System.out.println("\nErro lexico: \n" + e.getMessage());
      }catch (ParseException e) {
		System.out.println("\n"+e.toString()+"\nErro sintático encontrado, continuando análise após próximo \";\"\n");
		Token t;
		error=true;
		do {
		  t = getNextToken();
		} while (t.kind != PV);
		programa();
	}catch(ErroSemantico e){
  	  	System.out.println(e.getMessage());
		Token t;
	    do {
			t = getNextToken();
	    }while (t.kind != PV);
	    programa();
  	}
   }
}

PARSER_END(Compilador)
 
SKIP : { " " | "\t" | "\r" | "\n" }

//TOKENS DE COMANDOS 
TOKEN [IGNORE_CASE] : {
  		<EXIBE: "exibe" >  |
  		<LEITURA: "le" > | 
		<SE: "se" > |
      	<FIMSE: "fim-se" > |
      	<ENQUANTO: "enquanto" > |
      	<FIMENQUANTO: "fim-enquanto" > 
}
//TOKENS DE TIPOS 
TOKEN [IGNORE_CASE] : {
  		<NUMERO: "numero" >  |
  		<PALAVRA: "palavra" >  
}
//----------CARACTERES----------
TOKEN : {
		< #CHAR: ["a"-"z"] | ["A" - "Z"] > | 
   		< AP: "(" > |
    	< FP: ")" > |
		< PV: ";" > |
		< VIRGULA: "," > |
    	< STRING: "\"" (~["\""])* "\"" > |
   		< VAR: (< CHAR >)+ (["a" - "z", "A" - "Z" ,"0" - "9", "_"])* > 
}
//-----------NUMEROS-----------
TOKEN : {
	< #DIGIT: ["0"-"9"] > |  
    < NUM: (< DIGIT >)* (".")? (< DIGIT >)+ > 
}
//----------OPERADORES---------
TOKEN : {
 	< SOMA: "+" > |
	< SUB: "-" > |
	< MUL: "*" > |
    < DIV: "/" > |
    < OU: "OR" > |
    < ATRIB: "<-"  > |
    < IGUAL: "=" > |
   	< CONCAT: "&" > 
}

ListaComandoAltoNivel inicio(): { ListaComandoAltoNivel listaComandoAltoNivel; }
{
	listaComandoAltoNivel = programa() {  return listaComandoAltoNivel; }
}

ListaComandoAltoNivel programa():{
	ComandoAltoNivel _comando = null;
	ListaComandoAltoNivel listaComandoAltoNivel = new ListaComandoAltoNivel();
}
{
   		( _comando = comando(listaComandoAltoNivel){
		  if(_comando !=null) { 
		  	listaComandoAltoNivel.addComando( _comando );
			}
		  })* { return listaComandoAltoNivel; }
		 
  }

ComandoAltoNivel comando(ListaComandoAltoNivel listaComandoAltoNivel):{
	ComandoAltoNivel _comando = null;
}
{
  		(  		  declaracao(listaComandoAltoNivel)
  		|_comando = atribuicao()
  		|_comando = se()
  		|_comando = enquanto()
  		|le(listaComandoAltoNivel)
  		|exibe(listaComandoAltoNivel)
  		) { return _comando; }
}

ComandoAtribuicao atribuicao():{
	Token var;
	Token t;
	Expressao exp = null;
}
{
	var = < VAR >{ AcoesSemanticas.verificaDeclaracao(var,tabela); }
	t = < ATRIB >
	exp = expressao() < PV > { return new ComandoAtribuicao(tabela.consultaSimbolo(var.image),exp,t); }
}

void declaracao(ListaComandoAltoNivel listaComandoAltoNivel):{
  Token var,t=null;
  TipoDado tipo;
  Expressao exp=null,exp1=null;
}
{
  (    < NUMERO > { tipo=TipoDado.NUMERO; }| < PALAVRA > { tipo=TipoDado.PALAVRA; })
    var=< VAR >
    {
		AcoesSemanticas.declaraVariavel(var,tipo,tabela);
      }(t = < ATRIB > exp = expressao() { listaComandoAltoNivel.addComando(new ComandoAtribuicao(tabela.consultaSimbolo(var.image),exp,t)); } )?
	(	  < VIRGULA >var=< VAR >
	  {
		AcoesSemanticas.declaraVariavel(var,tipo,tabela);
		}
    (t = < ATRIB > exp = expressao() { listaComandoAltoNivel.addComando(new ComandoAtribuicao(tabela.consultaSimbolo(var.image),exp,t)); } )?)*< PV >
}

ComandoCondicional se() : {
	Token t;
	Expressao exp;
	ListaComandoAltoNivel listaTrue;
}
{
  t = < SE >< AP > exp = expressao() < FP > listaTrue = inicio() < FIMSE >{ return new ComandoCondicionalSimples(exp,listaTrue,t);}
}

ComandoEnquanto enquanto():{
  	Token t;
	Expressao exp;
	ListaComandoAltoNivel lista;
}
{
  t = < ENQUANTO > < AP > exp = expressao() < FP > lista = programa() < FIMENQUANTO > { return new ComandoEnquanto(exp,lista,t);}
}

void le(ListaComandoAltoNivel listaComandoAltoNivel) : { Token t; Token var;}
{
	t = < LEITURA > var = < VAR > { listaComandoAltoNivel.addComando( new ComandoEntrada(tabela.consultaSimbolo(var.image),t) ); } (< VIRGULA > var = < VAR >{ listaComandoAltoNivel.addComando( new ComandoEntrada(tabela.consultaSimbolo(var.image),t) ); })* < PV >
}

void exibe(ListaComandoAltoNivel listaComandoAltoNivel) : {Token t; Expressao exp; }
{
   t= < EXIBE > exp = expressao() { listaComandoAltoNivel.addComando( new ComandoSaida(exp,t) ); } (< VIRGULA >exp = expressao() { listaComandoAltoNivel.addComando( new ComandoSaida(exp,t) ); })* < PV >
}

Expressao expressao() : {Expressao pilha = new Expressao();}
{
  	expressao2(pilha){return pilha; }
}

void expressao2(Expressao pilha) : { Token t; }
{
  termo(pilha)(t=< OU >termo(pilha) {pilha.addItemPoxfixo(new Operador(t,TipoOperador.OR));})*
}

void termo(Expressao pilha) : {Token t; }
{
  termo1(pilha)(t=< IGUAL >termo1(pilha) {pilha.addItemPoxfixo(new Operador(t,TipoOperador.IGUAL));})?
}

void termo1(Expressao pilha) : {Token t; }
{
  termo2(pilha)(t=< CONCAT >termo2(pilha) {pilha.addItemPoxfixo(new Operador(t,TipoOperador.CONCAT));} )*
}

void termo2(Expressao pilha) : {Token t; TipoOperador tipoO;}
{
  termo3(pilha)((t=< SOMA >{ tipoO=TipoOperador.ADD; }|t=< SUB >{ tipoO=TipoOperador.SUB; })termo3(pilha){pilha.addItemPoxfixo(new Operador(t,tipoO));} )*
}

void termo3(Expressao pilha) : {Token t;TipoOperador tipoO; }
{
  termo4(pilha)((t=< MUL >{ tipoO=TipoOperador.MUL; }|t=< DIV >{ tipoO=TipoOperador.DIV; })termo4(pilha){pilha.addItemPoxfixo(new Operador(t,tipoO));} )*
}
void termo4(Expressao pilha) : {Token t;Token t1;}
{
   < AP > expressao2(pilha) < FP >
| (t = < NUM > { pilha.addItemPoxfixo(new Operando(t,TipoDado.NUMERO,TipoElemento.CTE)); }
| t1=< SOMA > t = < NUM > { pilha.addItemPoxfixo(new Operando(t,TipoDado.NUMERO,TipoElemento.CTE)); }
| t1=< SUB > t = < NUM > { pilha.addItemPoxfixo(new Operando(t,TipoDado.NUMERO,TipoElemento.CTE)); }
| t = < VAR > { AcoesSemanticas.verificaDeclaracao(t,tabela);pilha.addItemPoxfixo(new Operando(t,tabela.consultaTipo(t.image),TipoElemento.VAR)); }
| t = < STRING > { pilha.addItemPoxfixo(new Operando(t,TipoDado.PALAVRA,TipoElemento.CTE)); }
)
}

/*
Duvidas:
Como Resolver o problema de expressões do tipo +2+-3 e etc;
Arrumar Metodo de gerar comandos primitivos nas classes : ComandoSaida.
Falta Terminar o metodo geraCodigoDestino de Expressao,
pois tem alguns operadores não considerados (IGUAL,OR,CONCAT)
*/




